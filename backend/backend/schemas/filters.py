from pydantic import BaseModel
from typing import Optional

class Filters(BaseModel):
    limit: int
    market: str
    seed_artists: Optional[str]
    seed_genres: Optional[str]
    seed_tracks: Optional[str]
    min_acousticness: Optional[float]
    max_acousticness: Optional[float]
    target_acousticness: Optional[float]
    min_danceability: Optional[float]
    max_danceability: Optional[float]
    target_danceability: Optional[float]
    min_duration_ms: Optional[int]
    max_duration_ms: Optional[int]
    target_duration_ms: Optional[int]
    min_energy: Optional[float]
    max_energy: Optional[float]
    target_energy: Optional[float]
    min_instrumentalness: Optional[float]
    max_instrumentalness: Optional[float]
    target_instrumentalness: Optional[float]
    min_key: Optional[int]
    max_key: Optional[int]
    target_key: Optional[int]
    min_liveness: Optional[float]
    max_liveness: Optional[float]
    target_liveness: Optional[float]
    min_loudness: Optional[float]
    max_loudness: Optional[float]
    target_loudness: Optional[float]
    min_mode: Optional[float]
    max_mode: Optional[float]
    target_mode: Optional[float]
    min_popularity: Optional[int]
    max_popularity: Optional[int]
    target_popularity: Optional[int]
    min_speechiness: Optional[float]
    max_speechiness: Optional[float]
    target_speechiness: Optional[float]
    min_tempo: Optional[int]
    max_tempo: Optional[int]
    target_tempo: Optional[int]
    min_time_signature: Optional[int]
    max_time_signature: Optional[int]
    target_time_signature: Optional[int]
    min_valence: Optional[float]
    max_valence: Optional[float]
    target_valence: Optional[float]